<!DOCTYPE html> 

<html>
<head>
  <title>Javascript Racer - v4 (final)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="GameDesign.css" rel="stylesheet" type="text/css" />
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

  <script>
      var url_string = window.location.href; //window.location.href
      var url = new URL(url_string);
      var token = url.searchParams.get("token");
      var playername = null;
      $(document).ready(function () {
          $.get("sessionget.php", function (data, status) {
              // alert("Data: " + data + "\nStatus: " + status);

              // var foo = jQuery.parseJSON(data);
              var foo = data;
              playername = foo;
              // alert(playername);
          });
      });
      var PathNameForLink = window.location.href;
      var happy = PathNameForLink.replace("index.html","")
      var happy1 = happy.replace("file:///C:/", "");
      //var happy2 = happy1.replace(window.location.host & "/", "");
      var happy2 = window.location.protocol;

  </script>
</head> 

<body>



    <table id="controls" style="display:none">

        <tr><td id="fps" colspan="2" align="right"></td></tr>
        <tr>
            <th><label id="bgmLabel" for="bgm" align="right"></label><p>背景音樂:</p></th>

            <td style="width:40%;">
                <select id="bgm" style="width:100%" onchange="changeBGM()">
                    <optgroup>
                        <option value='music/可笑 Absurd.mp3'>可笑 Absurd</option>
                        <option value='music/休息日 Lazy Day.mp3'>休息日 Lazy Day</option>
                        <option value='music/休閒室 The Lounge.mp3'>休閒室 The Lounge</option>
                        <option value='music/完美解決 Solutions That Work.mp3'>完美解決 Solutions That Work</option>
                        <option value='music/美好回憶 Beautiful Memories.mp3'>美好回憶 Beautiful Memories</option>
                        <option value='music/美夢 Happy Dreams.mp3'>美夢 Happy Dreams</option>
                        <option value='music/旅館生活 Life At The Inn.mp3'>旅館生活 Life At The Inn</option>
                        <option selected value="music/開心 Feeling Happy.mp3">開心 Feeling Happy</option>
                        <option value="music/新方法 A New Way.mp3">新方法 A New Way</option>
                        <option value="music/熱帶小屋 Tropical House.mp3">熱帶小屋 Tropical House</option>
                    </optgroup>
                </select>
            </td>
        </tr>

        <tr>
            <th><label for="resolution">解析度 :</label></th>
            <td>
                <select id="resolution" style="width:100%">
                    <option value='fine'>Fine (1280x960)</option>
                    <option selected value='high'>High (1024x768)</option>
                    <option value='medium'>Medium (640x480)</option>
                    <option value='low'>Low (480x360)</option>
                </select>
            </td>
        </tr>
        <tr>
            <th><label for="lanes">車道 :</label></th>
            <td>
                <select id="lanes">
                    <option>1</option>
                    <option>2</option>
                    <option selected>3</option>
                    <option>4</option>
                    <option>5</option>
                    <option>6</option>
                    <option>7</option>
                    <option>100</option>
                </select>
            </td>
        </tr>
        <tr>
            <th><label for="difficultylevel">問題難度等級 :</label></th>
            <td>
                <select id="difficultylevel" style="width:100%">
                    <option selected value='withoutquestion'>沒有問題</option>
                    <option value='easy'>容易</option>
                    <option value='medium'>中等</option>
                    <option value='difficult'>困難</option>
                </select>
            </td>
        </tr>


        <tr>
            <th><label for="roadWidth">汽車尺寸<br />(<span id="currentRoadWidth"></span>) :</label></th>
            <td><input id="roadWidth" name="roadWidth" type='range' min='500' max='10000' title="integer (500-3000)" style="width:180px;"></td>
        </tr>
        <tr>
            <th><label for="totalCars">汽車總數<br />(<span id="currenttotalCars"></span>) :</label></th>
            <td> <input id="totalCars" name="totalCars" type='range' min='1' max='5000' title="integer (0-200)" style="width:180px;"></td>
        </tr>
        <tr>
            <th><label for="maxSpeed">最大速度<br />(<span id="currentmaxSpeed"></span>) :</label></th>
            <td><input id="maxSpeed" name="maxSpeed" type='range' min='12000' max='360000' title="integer (0-6000)" style="width:180px;"></td>
        </tr>
        <tr>
            <th> <label for="maxTime">遊戲時間<br />(<span id="currentmaxTime"></span>秒) :</label></th>
            <td> <input id="maxTime" name="maxTime" type='range' min='60' max='600' title="integer (0-6000)" style="width:180px;"></td>
        </tr>
        <tr>
            <th><label for="questionFrequency">問題頻率 <br />(<span id="currentQuestionFrequency"></span>秒) :</label></th>
            <td><input id="questionFrequency" name="questionFrequency" type='range' min='1' max='100' title="integer (1-5000)" style="width:180px;"></td>
        </tr>

    </table>

    <div id='instructions'>

        <div class="row">
            <input type="button" id="restartbutton" onclick="GetStart2()" value="開始遊戲" class="button">
            <input type="button" id="restartbutton" onclick="history.go(0)" value="重新開始" class="button">
            <button onclick="openFullscreen1();" class="button">全螢幕</button>
            <audio id="audioContainer" loop>
                <source src="music/開心 Feeling Happy.mp3" type="audio/mpeg">
            </audio>
            <span id="mute"></span>

            <audio id="audioContainer1" loop>
                <source src="music/road_sound.mp3" type="audio/mpeg">
            </audio>
            <br>
            <br>
            <button onclick="window.open('/'+'遊戲控制器設置說明書.pdf', '_blank', 'location=yes,height=1000,width=1000,scrollbars=yes,status=yes');" class="button" style="width:125px;height:50px;line-height: 20px;">遊戲控制器<br>設置說明書</button>
        </div>
        <p></p>
        <b>操作方法:</b>
        <p>使用<b>WASD鍵</b>或<b>方向鍵</b>控制人物</p>
        <img src="GameMap/CommonImages/keyboard1.png" style="width:131px;height:100px;">
        <img src="GameMap/CommonImages/keyboard2.jpg" style="width:131px;height:100px;">
        <b>道具功能:</b>
        <br>
        <button id="allitems" onclick="allitems();" class="button" style="width:130px;font-size:17px;">勾選全部道具</button>
        <button id="allitemsnot" onclick="allitemsnot();" class="button" style="width:130px;font-size:17px;">關閉所有道具</button>
        <table>
            <tr>
                <td><img src="GameMap/images_2/item1.png" style="width:50px;height:45px;"></td>
                <td><p>放大道路視線,分數增加</p><p>選擇開關這道具:<input id="ItemChoiceGlass" type="checkbox" value="true" checked style="width: 25px; height: 25px;"></input></p></td>
            </tr>
            <tr>
                <td><img src="GameMap/images_2/item2.png" style="width:50px;height:45px;"></td>
                <td><p>提高視線高度,分數增加</p><p>選擇開關這道具:<input id="ItemChoiceBallon" type="checkbox" value="true" checked style="width: 25px; height: 25px;"></input></p></td>
            </tr>
            <tr>
                <td><img src="GameMap/images_2/item3.png" style="width:50px;height:45px;"></td>
                <td><p>降低道路能見度,分數增加</p><p>選擇開關這道具:<input id="ItemChoiceCloud" type="checkbox" value="true" checked style="width: 25px; height: 25px;"></input></p></td>
            </tr>
            <tr>
                <td><img src="GameMap/images_2/item4.png" style="width:50px;height:45px;"></td>
                <td><p>提高道路能見度,分數增加</p><p>選擇開關這道具:<input id="ItemChoiceWind" type="checkbox" value="true" checked style="width: 25px; height: 25px;"></input></p></td>
            </tr>
            <tr>
                <td><img src="GameMap/images_2/item5.png" style="width:50px;height:45px;"></td>
                <td><p>移動速度提高2倍,分數增加</p><p>選擇開關這道具:<input id="ItemChoiceSpeedUp" type="checkbox" value="true" checked style="width: 25px; height: 25px;"></input></p></td>
            </tr>
            <tr>
                <td><img src="GameMap/images_2/item6.png" style="width:50px;height:45px;"></td>
                <td><p>額外分數增加</p><p>選擇開關這道具:<input id="ItemChoiceMoney" type="checkbox" value="true" checked style="width: 25px; height: 25px;"></input></p></td>
            </tr>
        </table>




    </div>

    <div id="racer">
        <object id="myObject">
            <canvas id="canvas" style="z-index:-1; width:100%; height:100%">

                Sorry, this example cannot be run because your browser does not support the &lt;canvas&gt; element
            </canvas>

            <div id="hud" style="z-index:0; width:100%">
                <img src="GameMap/CommonImages/polyu.gif" style="width: 50px;height:50px;float:left; margin-left:10px;">
                <span id="speed" class="hud"><span id="speed_value" class="value">0</span> 公里/小時</span>
                <span id="current_lap_time" class="hud">時間: <span id="current_lap_time_value" class="value">0.0</span></span>
                <span id="last_lap_time" style="display: none;" class="hud">Last Lap: <span id="last_lap_time_value" class="value">0.0</span></span>
                <span id="fast_lap_time" style="display: none;" class="hud">Fastest Lap: <span id="fast_lap_time_value" class="value">0.0</span></span>
                <span id="score" class="hud" style="float: left;">分數: <span id="score_value" class="value">0.0</span></span>
            </div>


            <div id="questionBar" style="z-index: 0; margin-top: 25px; margin-left: 25px; width: 70%; height: 50%; position: relative; left: 12%; top: 10%;">
                <img id="question" style="width:100%;height:100%;">
            </div>
            <div id="restart">
                <img src="GameMap/CommonImages/restart.gif" id="endImage">
            </div>
            <div id="nextLevel">
                <img src="GameMap/CommonImages/volcano_next.gif" id="endImage">
            </div>
            <div id="correct">
                <img src="GameMap/CommonImages/correct_ans.png">
            </div>
            <div id="wrong" style="z-index:1;">
                <img src="GameMap/CommonImages/wrong_ans.png">
            </div>
            <div id="errorKey">
                <img src="GameMap/CommonImages/error_key_msg.png">
            </div>
            <div id="toast" class="gameToast"></div>


        </object>
    </div>
    <p></p>
    <div id="resetroadd" class="row" style="display:none; ">
        <button onclick="resetRoadImages1();" class="button" style=" width: 250px;height:50px;">賽車軌道設計1</button>
        <button onclick="resetRoadImages2();" class="button" style=" width: 250px;height:50px;">賽車軌道設計2</button>
        <button onclick="resetRoadImages3();" class="button" style=" width: 250px;height:50px;">賽車軌道設計3</button>
        <br>
        <button onclick="resetRoadImages4();" class="button" style="width: 250px;height:50px;">賽車軌道設計4</button>
        <button onclick="resetRoadImages5();" class="button" style="width: 250px;height:50px;">賽車軌道設計5</button>
        <button onclick="resetRoadImages6();" class="button" style="width: 250px;height:50px;">賽車軌道設計6</button>
        <br>
        <button onclick="resetRoadImages7();" class="button" style="width: 250px;height:50px;">賽車軌道設計7</button>
        <button onclick="resetRoadImages8();" class="button" style="width: 250px;height:50px;">賽車軌道設計8</button>
        <button onclick="resetRoadImages9();" class="button" style="width: 250px;height:50px;">賽車軌道設計9</button>

    </div>








    <script src="FPSdisplay.js"></script>
    <script src="GameCode.js"></script>
    <script>
        //=========================================================================
        // Full Screen Function
        //=========================================================================
        var elem1 = document.getElementById("myObject")
        function openFullscreen1() {
            if (elem1.requestFullscreen) {
                elem1.requestFullscreen();
            }
        }
        //=========================================================================
        // General Game Parameter Setting
        //=========================================================================

        var fps = 120;                     // how many 'update' frames per second
        var step = 1 / fps;                   // how long is each frame (in seconds)
        var width = 1024;                    // logical canvas width
        var height = 768;                     // logical canvas height
        var centrifugal = 0.3;                     // centrifugal force multiplier when going around curves
        var offRoadDecel = 0.99;                    // speed multiplier when off road (e.g. you lose 2% speed each update frame)
        var skySpeed = 0.001;                   // background sky layer scroll speed when going around curve (or up hill)
        var hillSpeed = 0.002;                   // background hill layer scroll speed when going around curve (or up hill)
        var treeSpeed = 0.003;                   // background tree layer scroll speed when going around curve (or up hill)
        var skyOffset = 0;                       // current sky scroll offset
        var hillOffset = 0;                       // current hill scroll offset
        var treeOffset = 0;                       // current tree scroll offset
        var segments = [];                      // array of road segments
        var cars = [];                      // array of cars on the road
        var stats = Game.stats('fps');       // mr.doobs FPS counter
        var canvas = Dom.get('canvas');       // our canvas...
        var ctx = canvas.getContext('2d'); // ...and its drawing context
        var background = null;                    // our background image (loaded below)
        var sprites = null;                    // our spritesheet (loaded below)
        var playerFront = null;                    // Our Player      (Newly added)
        var resolution = null;                    // scaling factor to provide resolution independence (computed)
        var roadWidth = 2000;                    // actually half the roads width, easier math if the road spans from -roadWidth to +roadWidth
        var segmentLength = 200;                     // length of a single segment
        var rumbleLength = 3;                       // number of segments per red/white rumble strip
        var trackLength = null;                    // z length of entire track (computed)
        var lanes = 3;                       // number of lanes
        var fieldOfView = 100;                     // angle (degrees) for field of view
        var cameraHeight = 1000;                    // z height of camera
        var cameraDepth = null;                    // z distance camera is from screen (computed)
        var drawDistance = 300;                     // number of segments to draw
        var playerX = 0;                       // player x offset from center of road (-1 to 1 to stay independent of roadWidth)
        var playerZ = null;                    // player relative z distance from camera (computed)
        var fogDensity = 5;                       // exponential fog density
        var position = 0;                       // current camera Z position (add playerZ to get player's absolute Z position)
        var speed = 0;                       // current speed
        var maxSpeed = segmentLength / step / 2;      // top speed (ensure we can't move more than 1 segment in a single frame to make collision detection easier)
        var accel = maxSpeed / 4;             // acceleration rate - tuned until it 'felt' right
        var breaking = -maxSpeed;               // deceleration rate when braking
        var decel = -maxSpeed / 4;             // 'natural' deceleration rate when neither accelerating, nor braking
        var offRoadDecel = -maxSpeed / 2;             // off road deceleration is somewhere in between
        var offRoadLimit = maxSpeed / 2;             // limit when off road deceleration no longer applies (e.g. you can always go at least this speed even when off road)
        var totalCars = 150;                     // total number of cars on the road
        var currentLapTime = 0;                       // current lap time
        var lastLapTime = null;                    // last lap time
        var speedup = false;
        var speedUpTime = 0;
        var wind = false;                   // Wind weather condition
        var windTime = 0;
        var cloud = false;
        var cloudTime = 0;
        var ballon = false;
        var ballonTime = 0;
        var glass = false;
        var glassTime = 0;
        var numOfCrash = 0;
        var keyLeft = false;
        var keyRight = false;
        var keyFaster = false;
        var keySlower = false;
        var difficultylevel = "withoutquestion";
        var numberofquestion = 0;
        var maxTime = 360;
        var IsStarted = false;
        var questionFrequency = 15;
        var ItemChoiceMoney = true;
        var ItemChoiceSpeedUp = true;
        var ItemChoiceWind = true;
        var ItemChoiceCloud = true;
        var ItemChoiceBallon = true;
        var ItemChoiceGlass = true;
        var hud = {
            speed: { value: null, dom: Dom.get('speed_value') },
            current_lap_time: { value: null, dom: Dom.get('current_lap_time_value') },
            last_lap_time: { value: null, dom: Dom.get('last_lap_time_value') },
            fast_lap_time: { value: null, dom: Dom.get('fast_lap_time_value') },
            score: { value: null, dom: Dom.get('score_value') },
        }
        var question_counter = 0;
        var question_ans = 0;
        var question_asked = [];
        var musicAutoplay = false;
        var mapchoice = [];
        var randomstage = Math.floor(Math.random() * 3) + 1;
        var b = 0;
        switch (randomstage) {
            case 1: mapchoice = ["1", "2", "3"]; break;
            case 2: mapchoice = ["4", "5", "6"]; break;
            case 3: mapchoice = ["7", "8", "9"]; break;
        }
        //=====================================
        //以下代碼可用於選擇您喜歡的遊戲關卡
        //如果您不需要，可以通過以下方式禁用它
        // Before: var mapchoice = ["9"];
        // After : // var mapchoice = ["9"];
        //=====================================
         //      var mapchoice = ["9"];
        //==================================
        console.log(mapchoice);

        function shuffle(arr) {
            var i,
                j,
                temp;
            for (i = arr.length - 1; i > 0; i--) {
                j = Math.floor(Math.random() * (i + 1));
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
            return arr;

        };
      //shuffle(mapchoice);
        var levelnumber;
        function gamelevelstage() {
            switch (b) {
                case 1: levelnumber = "第一"; break;
                case 2: levelnumber = "第二"; break;
                case 3: levelnumber = "最後一"; break;
            }

            displayToast("<br>" + levelnumber + "關");
        };
        function postScore() {
            // alert("runned");

            $.ajax({
                url: 'post.php',
                type: 'post',
                data: { name: playername, stage: stagename, time: convertToSQLTime(lastLapTime) },
                success: function (data) {
                    // alert(data); // Inspect this in your

                }
            });

        }

        function convertToSQLTime(dt) {
            var minutes = Math.floor(dt / 60);
            var seconds = Math.floor(dt - (minutes * 60));
            var tenths = Math.floor(10 * (dt - Math.floor(dt)));
            if (minutes > 0)
                return minutes + ":" + (seconds < 10 ? "0" : "") + seconds;
            else
                return seconds;
        }
        window.requestAnimFrame = (function () {
            return window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                function (callback) {
                    window.setTimeout(callback, 1000 / 60);
                };
        })();
        function wait() {
            reset();
            setTimeout(" drawsomething();", 1);
        };

    //=========================================================================
    // Index Page Display Function
    //=========================================================================
        setTimeout("GetStart()", 7000);
        function GetStart() {
            document.getElementById('canvas').style.background = "url('GameMap/CommonImages/Intermediate.gif')";
            document.getElementById('canvas').style.backgroundSize = "100% 90%";
            document.getElementById('canvas').style.backgroundPosition = "bottom";
        }
        function GetStart2() {
            if (b > 0) {
                // console.log(b);
            }
            else {
                document.getElementById('canvas').style.background = "url('GameMap/CommonImages/Ending.gif')";
                document.getElementById('canvas').style.backgroundSize = "100% 90%";
                document.getElementById('canvas').style.backgroundPosition = "bottom";
                setTimeout("startGame()", 2000);
            }
        }
    //=========================================================================
    // Item Activation Selection 
    //=========================================================================
        function allitems() {
            document.getElementById("ItemChoiceMoney").checked = true;
            document.getElementById("ItemChoiceSpeedUp").checked = true;
            document.getElementById("ItemChoiceWind").checked = true;
            document.getElementById("ItemChoiceCloud").checked = true;
            document.getElementById("ItemChoiceBallon").checked = true;
            document.getElementById("ItemChoiceGlass").checked = true;

        }
        function allitemsnot() {
            document.getElementById("ItemChoiceMoney").checked = false;
            document.getElementById("ItemChoiceSpeedUp").checked = false;
            document.getElementById("ItemChoiceWind").checked = false;
            document.getElementById("ItemChoiceCloud").checked = false;
            document.getElementById("ItemChoiceBallon").checked = false;
            document.getElementById("ItemChoiceGlass").checked = false;

        }

    //=========================================================================
    // UPDATE THE GAME WORLD
    //=========================================================================

        async function update(dt) {

            var n, car, carW, sprite, spriteW;
            var playerSegment = findSegment(position + playerZ);
            var playerW = SPRITES.PLAYER_STRAIGHT.w * SPRITES.SCALE;
            var speedPercent = speed / maxSpeed;
            var dx = dt * 2 * speedPercent; // at top speed, should be able to cross from left to right (-1 to 1) in 1 second
            var startPosition = position;

            updateCars(dt, playerSegment, playerW);

            position = Util.increase(position, dt * speed, trackLength);
    //=====================================================
    //   Player Controller Setting
    //=====================================================
            if (keyLeft)
                playerX = playerX - dx;
            else if (keyRight)
                playerX = playerX + dx;

            playerX = playerX - (dx * speedPercent * playerSegment.curve * centrifugal);

            if (keyFaster)
                speed = Util.accelerate(speed, accel, dt);
            else if (keySlower)
                speed = Util.accelerate(speed, breaking, dt);
            else
                speed = Util.accelerate(speed, decel, dt);


            if ((playerX < -1) || (playerX > 1)) {

                if (speed > offRoadLimit)
                    speed = Util.accelerate(speed, offRoadDecel, dt);

                for (n = 0; n < playerSegment.sprites.length; n++) {
                    sprite = playerSegment.sprites[n];
                    spriteW = sprite.source.w * SPRITES.SCALE;
                    if (Util.overlap(playerX, playerW, sprite.offset + spriteW / 2 * (sprite.offset > 0 ? 1 : -1), spriteW)) {
                        speed = maxSpeed / 4;
                        //position = Util.increase(playerSegment.p1.world.z, -playerZ, trackLength); // stop in front of sprite (at front of segment)
                        break;
                    }
                }
            }



    //=====================================================
    //   Item Effect Setting
    //=====================================================
            for (n = 0; n < playerSegment.cars.length; n++) {
                car = playerSegment.cars[n];
                carW = car.sprite.w * SPRITES.SCALE;

                // console.log("car: " + car.offset);
                // console.log("carW: " + carW);

                if (speed > car.speed) {

                    //console.log(car.type);

                    if (car.type == "prop") {
                        if (Util.overlap(playerX, playerW, car.offset, carW, 0.8)) {
                            speed = maxSpeed / 4;
                            position = Util.increase(car.z, -playerZ, trackLength);
                            //console.log("runned");
                            var audio = new Audio('music/car_sound.mp3');
                            audio.volume = 0.002;
                            audio.play();
                            break;

                        }
                    }
                    else if (car.type == "speedUp") {
                        // console.log("speed: " + car.speed);
                        if (Util.overlap(playerX, playerW, car.offset, carW, 0.8)) {
                            speedUpTime = currentLapTime + 5;
                            speedup = true;
                            speed = 24000;
                            numOfCrash += 1;
                            var audio = new Audio('music/superwoman_cloak.mp3');
                            audio.volume = 0.1;
                            audio.play();
                            // position = Util.increase(car.z, -playerZ, trackLength);
                            break;
                        }
                    }
                    //wind item test
                    else if (car.type == "wind") {
                        //console.log("wind");
                        if (Util.overlap(playerX, playerW, car.offset, carW, 0.8)) {
                            windTime = currentLapTime + 10;

                            //remove wind effect
                            cloudTime = 0;
                            cloud = false;
                            numOfCrash += 1;
                            wind = true;
                            fogDensity = 0;
                            drawDistance = 400;
                            var audio = new Audio('music/wind_cloud.mp3');
                            audio.volume = 0.1;
                            audio.play();
                            // position = Util.increase(car.z, -playerZ, trackLength);
                            break;
                        }
                    }
                    else if (car.type == "cloud") {
                        //console.log("cloud");
                        if (Util.overlap(playerX, playerW, car.offset, carW, 0.8)) {

                            cloudTime = currentLapTime + 10;
                            //remove wind effect
                            windTime = 0;
                            wind = false;
                            numOfCrash += 1;
                            cloud = true;
                            fogDensity = 50;
                            drawDistance = 220;
                            var audio = new Audio('music/wind_cloud.mp3');
                            audio.volume = 0.1;
                            audio.play();
                            // position = Util.increase(car.z, -playerZ, trackLength);
                            break;
                        }
                    }
                    else if (car.type == "ballon") {
                        if (Util.overlap(playerX, playerW, car.offset, carW, 0.8)) {

                            ballonTime = currentLapTime + 10;
                            //remove wind effect
                            glassTime = 0;
                            glass = false;
                            numOfCrash += 1;
                            ballon = true;
                            cameraHeight = 1300;
                            var audio = new Audio('music/balloon_magnifying glass.mp3');
                            audio.volume = 0.1;
                            audio.play();
                            // position = Util.increase(car.z, -playerZ, trackLength);
                            break;
                        }
                    }
                    else if (car.type == "glass") {
                        if (Util.overlap(playerX, playerW, car.offset, carW, 0.8)) {

                            glassTime = currentLapTime + 10;
                            //remove wind effect
                            ballonTime = 0;
                            ballon = false;
                            numOfCrash += 1;
                            glass = true;
                            cameraHeight = 500;
                            var audio = new Audio('music/balloon_magnifying glass.mp3');
                            audio.volume = 0.1;
                            audio.play();
                            // position = Util.increase(car.z, -playerZ, trackLength);
                            break;
                        }
                    }
                    else if (car.type == "money") {
                        if (Util.overlap(playerX, playerW, car.offset, carW, 0.8)) {

                            numOfCrash += 10;


                            var audio = new Audio('music/balloon_magnifying glass.mp3');
                            audio.volume = 0.1;
                            audio.play();
                            // position = Util.increase(car.z, -playerZ, trackLength);
                            break;
                        }
                    }
                    else {
                        speed = maxSpeed / 4;
                        position = Util.increase(car.z, -playerZ, trackLength);
                        break;
                    }


                }
            }

            //check tools condition
            if (currentLapTime >= speedUpTime) {
                speedup = false;
                speedUpTime = 0;
            }

            // console.log("fog: " + fogDensity);
            if (currentLapTime >= windTime && cloudTime == 0) {
                wind = false;
                fogDensity = 5;
                drawDistance = 300;
            }

            if (currentLapTime >= cloudTime && windTime == 0) {
                cloud = false;
                fogDensity = 5;
                drawDistance = 300;
            }

            if (currentLapTime >= glassTime && ballonTime == 0) {
                glass = false;
                cameraHeight = 1000;
            }

            if (currentLapTime >= ballonTime && glassTime == 0) {
                ballon = false;
                cameraHeight = 1000;
            }

            playerX = Util.limit(playerX, -3, 3);     // dont ever let it go too far out of bounds
            //check max speed
            if (speedup == false) {
                speed = Util.limit(speed, 0, maxSpeed / 2);
            }
            else {
                speed = Util.limit(speed, 0, maxSpeed);
            }
        //=====================================================
        //   Background positioning
        //=====================================================


            skyOffset = Util.increase(skyOffset, skySpeed * playerSegment.curve * (position - startPosition) / segmentLength, 1);
            hillOffset = Util.increase(hillOffset, hillSpeed * playerSegment.curve * (position - startPosition) / segmentLength, 1);
            treeOffset = Util.increase(treeOffset, treeSpeed * playerSegment.curve * (position - startPosition) / segmentLength, 1);
        //=====================================================
        //     Finishing Line incidents
        //=====================================================
            if (position > playerZ) {
                var x = Math.round(currentLapTime * 10 + numOfCrash * 100);
                if (currentLapTime && (startPosition < playerZ)) {
                    // lastLapTime = currentLapTime;
                    //currentLapTime = 0;
                    if (lastLapTime <= Util.toFloat(Dom.storage.fast_lap_time)) {
                        //  Dom.storage.fast_lap_time = lastLapTime;
                        // updateHud('fast_lap_time', formatTime(lastLapTime));
                        // Dom.addClassName('fast_lap_time', 'fastest');
                        //Dom.addClassName('last_lap_time', 'fastest');
                    }
                    else {
                        // Dom.removeClassName('fast_lap_time', 'fastest');
                        //   Dom.removeClassName('last_lap_time', 'fastest');
                    }
                    // updateHud('last_lap_time', formatTime(lastLapTime));
                    //Dom.show('last_lap_time');


                    //=====================================================
                    //   Conditions When Arriving at the finishing line
                    //=====================================================
                    if (parseInt(currentLapTime) > parseInt(maxTime)) {
                        var sound_effect = new Audio("sound effect/stage fail.mp3");
                        document.getElementById("restart").style.display = "block";
                        document.getElementById("current_lap_time").style.display = "none";
                        document.getElementById("score").style.display = "none";
                        sound_effect.play();
                        maxSpeed = 0;
                        //wait 6 second
                        await new Promise(r => setTimeout(r, 5000));
                        window.location.reload();
                    } else {
                        //document.getElementById("nextLevel").style.display = "block";
                        var sound_effect = new Audio("sound effect/stage clear.mp3");
                        sound_effect.play();
                        // document.getElementById("current_lap_time").style.display = "none";
                        // document.getElementById("score").style.display = "none";

                        switch (b) {
                            case 1: NextGameStage(); break;
                            case 2: NextGameStage(); break;
                            case 3:

                                document.getElementById("current_lap_time").style.display = "none";
                                document.getElementById("score").style.display = "none";
                                keyLeft = keyRight = keySlower = keyFaster = false;
                                maxSpeed = 0;

                                document.getElementById('canvas').style.background = "url('GameMap/CommonImages/Endgame.gif')";
                                document.getElementById('canvas').style.backgroundSize = "100% 100%";
                                document.getElementById('toast').style.background = "url('')";
                                document.getElementById('toast').style.backgroundSize = "100% 100%";
                                document.getElementById('toast').style.fontSize = "30px";
                                document.getElementById('toast').style.top = "4%";
                                document.getElementById('toast').style.padding = "0px 0px";
                                document.getElementById('toast').style.backgroundColor = "";
                                displayToast("<br><b>遊戲結束</b><br>恭喜您<br>在<b>" + Math.round((maxTime / 60) * 100) / 100 + "</b>分鐘內完成了遊戲<br>你的分數是<b>" + x + "</b", "inf");
                                wait();
                                break;
                        }

                        // hello();
                        //   maxSpeed = 0;
                        //  keyLeft = keyRight = keySlower = keyFaster = false;
                        // var nextlevelloop = false;
                        //  stopnext(nextlevelloop);

                        // document.getElementById('toast').style.background = "url('GameMap/CommonImages/final.gif')";
                        // document.getElementById('toast').style.backgroundSize = "100% 100%";
                        //  displayToast("<br>遊戲結束<br>你的分數是" + x, "inf");

                        //alert("你的分數是" + x);
                        // postScore();
                        //wait 6 second
                        // await new Promise(r => setTimeout(r, 6000));
                        //change to index (awaiting change for production)


                        //var nextStage = Util.randomInt(0, 1);
                        //window.location.reload();
                        //if (nextStage == 0) {
                        //  window.location.replace("polar.html");
                        //}
                        //else {
                        //   window.location.replace("sky.html");
                        // }


                    }

                }
                else {
                    currentLapTime += dt;
                    // console.log(dt);
                }
            }

            //call question
            if (parseInt(currentLapTime) % questionFrequency == 0 && parseInt(currentLapTime) != 0) {
                updateQuestions();
            }
            // console.log(currentLapTime);
            updateHud('speed', 5 * Math.round(speed / 500));
            updateHud('current_lap_time', formatTime(currentLapTime));
            updateHud('score', Math.round(currentLapTime * 10 + numOfCrash * 100));


        }

        //-------------------------------------------------------------------------
         //=========================================================================
        // Update The Game elements
        //=========================================================================
        function updateQuestions() {
            var questionBar_style = window.getComputedStyle(document.getElementById("questionBar"));
            if (questionBar_style.display == "none" && question_counter < numberofquestion) {
                var img = document.getElementById("question");
                question_ans = Math.floor(Math.random() * 3) + 1;
                var image_num = Math.floor(Math.random() * 5) + 1;

                var source = "QuestionDifficulty/" + difficultylevel + "/question/" + question_ans + "/" + image_num + ".png";

                var check = question_asked.includes(source);
                if (!check) {
                    question_asked[question_counter] = source;
                    img.src = source;
                    question_counter++;
                    document.getElementById("questionBar").style.display = "block";
                } else {
                    updateQuestions();
                }
            }
        }

        function updateCars(dt, playerSegment, playerW) {
            var n, car, oldSegment, newSegment;
            for (n = 0; n < cars.length; n++) {
                car = cars[n];
                oldSegment = findSegment(car.z);
                car.offset = car.offset + updateCarOffset(car, oldSegment, playerSegment, playerW);
                car.z = Util.increase(car.z, dt * car.speed, trackLength);
                car.percent = Util.percentRemaining(car.z, segmentLength); // useful for interpolation during rendering phase
                newSegment = findSegment(car.z);
                if (oldSegment != newSegment) {
                    index = oldSegment.cars.indexOf(car);
                    oldSegment.cars.splice(index, 1);
                    newSegment.cars.push(car);
                }
            }
        }

        function updateCarOffset(car, carSegment, playerSegment, playerW) {

            var i, j, dir, segment, otherCar, otherCarW, lookahead = 20, carW = car.sprite.w * SPRITES.SCALE;

            // optimization, dont bother steering around other cars when 'out of sight' of the player
            if ((carSegment.index - playerSegment.index) > drawDistance)
                return 0;

            for (i = 1; i < lookahead; i++) {
                segment = segments[(carSegment.index + i) % segments.length];

                if ((segment === playerSegment) && (car.speed > speed) && (Util.overlap(playerX, playerW, car.offset, carW, 1.2))) {
                    if (playerX > 0.5)
                        dir = -1;
                    else if (playerX < -0.5)
                        dir = 1;
                    else
                        dir = (car.offset > playerX) ? 1 : -1;
                    return dir * 1 / i * (car.speed - speed) / maxSpeed; // the closer the cars (smaller i) and the greated the speed ratio, the larger the offset
                }

                for (j = 0; j < segment.cars.length; j++) {
                    otherCar = segment.cars[j];
                    otherCarW = otherCar.sprite.w * SPRITES.SCALE;
                    if ((car.speed > otherCar.speed) && Util.overlap(car.offset, carW, otherCar.offset, otherCarW, 1.2)) {
                        if (otherCar.offset > 0.5)
                            dir = -1;
                        else if (otherCar.offset < -0.5)
                            dir = 1;
                        else
                            dir = (car.offset > otherCar.offset) ? 1 : -1;
                        return dir * 1 / i * (car.speed - otherCar.speed) / maxSpeed;
                    }
                }
            }

            // if no cars ahead, but I have somehow ended up off road, then steer back on
            if (car.offset < -0.9)
                return 0.1;
            else if (car.offset > 0.9)
                return -0.1;
            else
                return 0;
        }

        //-------------------------------------------------------------------------

        function updateHud(key, value) { // accessing DOM can be slow, so only do it if value has changed
            if (hud[key].value !== value) {
                hud[key].value = value;
                Dom.set(hud[key].dom, value);
            }
        }

        function formatTime(dt) {
            var minutes = Math.floor(dt / 60);
            var seconds = Math.floor(dt - (minutes * 60));
            var tenths = Math.floor(10 * (dt - Math.floor(dt)));
            if (minutes > 0)
                return minutes + "." + (seconds < 10 ? "0" : "") + seconds + "." + tenths;
            else
                return seconds + "." + tenths;
        }

        //=========================================================================
        // RENDER THE GAME WORLD
        //=========================================================================

        function render() {

            var baseSegment = findSegment(position);
            var basePercent = Util.percentRemaining(position, segmentLength);
            var playerSegment = findSegment(position + playerZ);
            var playerPercent = Util.percentRemaining(position + playerZ, segmentLength);
            var playerY = Util.interpolate(playerSegment.p1.world.y, playerSegment.p2.world.y, playerPercent);
            var maxy = height;

            var x = 0;
            var dx = - (baseSegment.curve * basePercent);

            ctx.clearRect(0, 0, width, height);

        //=========================================================================
        // For rendering Background
        //=========================================================================
            Render.background(ctx, bg1, width, height, BACKGROUND.SKY, skyOffset, resolution * skySpeed * playerY);
            Render.background(ctx, bg2, width, height, BACKGROUND.HILLS, hillOffset, resolution * hillSpeed * playerY);
            Render.background(ctx, bg3, width, height, BACKGROUND.TREES, treeOffset, resolution * treeSpeed * playerY);

            var n, i, segment, car, sprite, spriteScale, spriteX, spriteY;

            for (n = 0; n < drawDistance; n++) {

                segment = segments[(baseSegment.index + n) % segments.length];
                segment.looped = segment.index < baseSegment.index;
                segment.fog = Util.exponentialFog(n / drawDistance, fogDensity);
                segment.clip = maxy;

                Util.project(segment.p1, (playerX * roadWidth) - x, playerY + cameraHeight, position - (segment.looped ? trackLength : 0), cameraDepth, width, height, roadWidth);
                Util.project(segment.p2, (playerX * roadWidth) - x - dx, playerY + cameraHeight, position - (segment.looped ? trackLength : 0), cameraDepth, width, height, roadWidth);

                x = x + dx;
                dx = dx + segment.curve;

                if ((segment.p1.camera.z <= cameraDepth) || // behind us
                    (segment.p2.screen.y >= segment.p1.screen.y) || // back face cull
                    (segment.p2.screen.y >= maxy))                  // clip by (already rendered) hill
                    continue;

                Render.segment(ctx, width, lanes,
                    segment.p1.screen.x,
                    segment.p1.screen.y,
                    segment.p1.screen.w,
                    segment.p2.screen.x,
                    segment.p2.screen.y,
                    segment.p2.screen.w,
                    segment.fog,
                    segment.color);

                maxy = segment.p1.screen.y;
            }

            for (n = (drawDistance - 1); n > 0; n--) {
                segment = segments[(baseSegment.index + n) % segments.length];



        //=========================================================================
        // For rendering Car
        //=========================================================================
                for (i = 0; i < segment.cars.length; i++) {
                    car = segment.cars[i];
                    sprite = car.sprite;
                    spriteScale = Util.interpolate(segment.p1.screen.scale, segment.p2.screen.scale, car.percent);
                    spriteX = Util.interpolate(segment.p1.screen.x, segment.p2.screen.x, car.percent) + (spriteScale * car.offset * roadWidth * width / 2);
                    spriteY = Util.interpolate(segment.p1.screen.y, segment.p2.screen.y, car.percent);
                    carSprites = car.carImage;
                    // console.log(car.carImage);
                    // console.log(sprite);
                    Render.sprite(ctx, width, height, resolution, roadWidth, carSprites, car.sprite, spriteScale, spriteX, spriteY, -0.5, -1, segment.clip);
                }


        //=========================================================================
        // For rendering Sprite
        //=========================================================================
                for (i = 0; i < segment.sprites.length; i++) {
                    sprite = segment.sprites[i];
                    spriteScale = segment.p1.screen.scale;
                    spriteX = segment.p1.screen.x + (spriteScale * sprite.offset * roadWidth * width / 2);
                    spriteY = segment.p1.screen.y;
                    image = sprite.spriteImage;
                    //  console.log(image);
                    Render.sprite(ctx, width, height, resolution, roadWidth, image, sprite.source, spriteScale, spriteX, spriteY, -0.5, -1, segment.clip);
                }
        //=========================================================================
        // For rendering Player
        //=========================================================================
                if (segment == playerSegment) {
                    Render.player(ctx, width * .75, height * .75, resolution, roadWidth, playerFront, speed / maxSpeed,
                        cameraDepth * .6 / playerZ,
                        width / 2,
                        (height / 2) - (cameraDepth / playerZ * Util.interpolate(playerSegment.p1.camera.y, playerSegment.p2.camera.y, playerPercent) * height / 2),
                        turning(),
                        playerSegment.p2.world.y - playerSegment.p1.world.y);
                }
            }
        }
        //=========================================================================
        // Car Turnning Angle
        //=========================================================================

        var TurningAngle = 0;
        function turning() {
            if (keyRight) {
                if (TurningAngle < 90) { TurningAngle += 10; return TurningAngle; }
                else { return TurningAngle; }
            }
            else if (keyLeft) {
                if (TurningAngle > -90) { TurningAngle -= 10; return TurningAngle; }
                else { return TurningAngle; }
            }
            else if (keyRight == false && keyLeft == false && TurningAngle != 0) {
                if (TurningAngle >= -90 && TurningAngle < 0) {
                    TurningAngle += 10;
                    return TurningAngle;
                }
                else if (TurningAngle <= 90 && TurningAngle > 0) {
                    TurningAngle -= 10;
                    return TurningAngle;
                }
                return TurningAngle;
            }
            else { return TurningAngle; }

        }

        //=========================================================================
        // Segement positioning
        //=========================================================================
        function findSegment(z) {
            return segments[Math.floor(z / segmentLength) % segments.length];
        }

        //=========================================================================
        // BUILD ROAD GEOMETRY
        //=========================================================================

        function lastY() { return (segments.length == 0) ? 0 : segments[segments.length - 1].p2.world.y; }

        function addSegment(curve, y) {
            var n = segments.length;
            segments.push({
                index: n,
                p1: { world: { y: lastY(), z: n * segmentLength }, camera: {}, screen: {} },
                p2: { world: { y: y, z: (n + 1) * segmentLength }, camera: {}, screen: {} },
                curve: curve,
                sprites: [],
                cars: [],
                color: Math.floor(n / rumbleLength) % 2 ? COLORS.DARK : COLORS.LIGHT
            });
        }

        //add sprite
        function addSprite(n, sprite, image, offset) {
            segments[n].sprites.push({ source: sprite, spriteImage: image, offset: offset });
        }

        function addRoad(enter, hold, leave, curve, y) {
            var startY = lastY();
            var endY = startY + (Util.toInt(y, 0) * segmentLength);
            var n, total = enter + hold + leave;
            for (n = 0; n < enter; n++)
                addSegment(Util.easeIn(0, curve, n / enter), Util.easeInOut(startY, endY, n / total));
            for (n = 0; n < hold; n++)
                addSegment(curve, Util.easeInOut(startY, endY, (enter + n) / total));
            for (n = 0; n < leave; n++)
                addSegment(Util.easeInOut(curve, 0, n / leave), Util.easeInOut(startY, endY, (enter + hold + n) / total));
        }

        var ROAD = {
            LENGTH: { NONE: 0, SHORT: 25, MEDIUM: 50, LONG: 100 },
            HILL: { NONE: 0, LOW: 20, MEDIUM: 40, HIGH: 60 },
            CURVE: { NONE: 0, EASY: 2, MEDIUM: 4, HARD: 6 }
        };
        //=====================================================================
        //                 Elements for Generating Road
        //=====================================================================
        function addStraight(num) {
            num = num || ROAD.LENGTH.MEDIUM;
            addRoad(num, num, num, 0, 0);
        }

        function addHill(num, height) {
            num = num || ROAD.LENGTH.MEDIUM;
            height = height || ROAD.HILL.MEDIUM;
            addRoad(num, num, num, 0, height);
        }

        function addCurve(num, curve, height) {
            num = num || ROAD.LENGTH.MEDIUM;
            curve = curve || ROAD.CURVE.MEDIUM;
            height = height || ROAD.HILL.NONE;
            addRoad(num, num, num, curve, height);
        }

        function addLowRollingHills(num, height) {
            num = num || ROAD.LENGTH.SHORT;
            height = height || ROAD.HILL.LOW;
            addRoad(num, num, num, 0, height / 2);
            addRoad(num, num, num, 0, -height);
            addRoad(num, num, num, ROAD.CURVE.EASY, height);
            addRoad(num, num, num, 0, 0);
            addRoad(num, num, num, -ROAD.CURVE.EASY, height / 2);
            addRoad(num, num, num, 0, 0);
        }

        function addSCurves() {
            addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, -ROAD.CURVE.EASY, ROAD.HILL.NONE);
            addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.CURVE.MEDIUM, ROAD.HILL.MEDIUM);
            addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.CURVE.EASY, -ROAD.HILL.LOW);
            addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, -ROAD.CURVE.EASY, ROAD.HILL.MEDIUM);
            addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, -ROAD.CURVE.MEDIUM, -ROAD.HILL.MEDIUM);
        }

        function addBumps() {
            addRoad(10, 10, 10, 0, 5);
            addRoad(10, 10, 10, 0, -2);
            addRoad(10, 10, 10, 0, -5);
            addRoad(10, 10, 10, 0, 8);
            addRoad(10, 10, 10, 0, 5);
            addRoad(10, 10, 10, 0, -7);
            addRoad(10, 10, 10, 0, 5);
            addRoad(10, 10, 10, 0, -2);
        }

        function addBumps1() {
            addRoad(10, 10, 10, 0, 2);
            addRoad(10, 10, 10, 0, -5);
            addRoad(10, 10, 10, 0, 5);
            addRoad(10, 10, 10, 0, -8);
            addRoad(10, 10, 10, 0, 10);
            addRoad(10, 10, 10, 0, -8);
            addRoad(10, 10, 10, 0, 7);
            addRoad(10, 10, 10, 0, -5);
        }

        function addBumps2() {
            addRoad(10, 10, 10, 0, 8);
            addRoad(10, 10, 10, 5, -8);
            addRoad(10, 10, 10, -5, 9);
            addRoad(10, 10, 10, 6, -1);
            addRoad(10, 10, 10, -3, 3);
            addRoad(10, 10, 10, 4, -3);
            addRoad(10, 10, 10, -5, 1);
            addRoad(10, 10, 10, 5, -3);
        }

        function addDownhillToEnd(num) {
            num = num || 200;
            addRoad(num, num, num, -ROAD.CURVE.EASY, -lastY() / segmentLength);
        }

        //=====================================================================
        //                       Road Generating
        //=====================================================================
        function resetRoadImages1() {  // image_5
            segments = [];


            addStraight(ROAD.LENGTH.SHORT);
            addLowRollingHills(ROAD.LENGTH.NONE);
            addSCurves(ROAD.LENGTH.NONE);
            addCurve(ROAD.LENGTH.NONE, ROAD.CURVE.MEDIUM, ROAD.HILL.LOW);
            addBumps(ROAD.LENGTH.NONE);
            addLowRollingHills(ROAD.LENGTH.SHORT);
            addCurve(ROAD.LENGTH.SHORT, ROAD.CURVE.MEDIUM, ROAD.HILL.MEDIUM);
            addBumps(ROAD.LENGTH.SHORT);
            addHill(ROAD.LENGTH.SHORT, -ROAD.HILL.MEDIUM);
            addDownhillToEnd();



            resetSpritesImages1();
            resetCars();
            console.log(segments.length);

            segments[findSegment(playerZ).index + 1].color = COLORS.START;
            segments[findSegment(playerZ).index + 2].color = COLORS.START1;
            segments[findSegment(playerZ).index + 3].color = COLORS.START;

            for (var n = 0; n < rumbleLength; n++)
                segments[segments.length - 1 - n].color = COLORS.START;
            segments[segments.length - 2 - n].color = COLORS.START1;
            segments[segments.length - 3 - n].color = COLORS.START;

            trackLength = segments.length * segmentLength;
            //console.log(mapchoice[b - 1]);
            console.log(segments.length);
        }

        function resetRoadImages2() {
            segments = [];

            addStraight(ROAD.LENGTH.SHORT);
            addDownhillToEnd();
            addStraight(ROAD.LENGTH.SHORT);
            addStraight(ROAD.LENGTH.SHORT);
            addDownhillToEnd();
            addStraight(ROAD.LENGTH.SHORT);
            addStraight(ROAD.LENGTH.SHORT);
            addDownhillToEnd();
            addStraight(ROAD.LENGTH.SHORT);
            addStraight(ROAD.LENGTH.SHORT);
            addDownhillToEnd();
            addStraight(ROAD.LENGTH.SHORT);


            resetSpritesImages1();
            resetCars();
            segments[findSegment(playerZ).index + 1].color = COLORS.START;
            segments[findSegment(playerZ).index + 2].color = COLORS.START1;
            segments[findSegment(playerZ).index + 3].color = COLORS.START;

            for (var n = 0; n < rumbleLength; n++)
                segments[segments.length - 1 - n].color = COLORS.START;
            segments[segments.length - 2 - n].color = COLORS.START1;
            segments[segments.length - 3 - n].color = COLORS.START;
            console.log(segments.length);
            trackLength = segments.length * segmentLength;
         
        }

        function resetRoadImages3() {
            segments = [];

            addHill(ROAD.LENGTH.SHORT, ROAD.HILL.HIGH);
            addCurve();
            addCurve(ROAD.LENGTH.SHORT, ROAD.CURVE.MEDIUM, ROAD.HILL.MEDIUM);
            addBumps();
            addLowRollingHills();
            addHill(ROAD.LENGTH.SHORT, ROAD.HILL.HIGH);
            addSCurves();
            addBumps();
            addHill(ROAD.LENGTH.SHORT, -ROAD.HILL.MEDIUM);
            addStraight();
            addSCurves();
            addDownhillToEnd();

            resetSpritesImages1();
            resetCars();

            segments[findSegment(playerZ).index + 1].color = COLORS.START;
            segments[findSegment(playerZ).index + 2].color = COLORS.START1;
            segments[findSegment(playerZ).index + 3].color = COLORS.START;

            for (var n = 0; n < rumbleLength; n++)
                segments[segments.length - 1 - n].color = COLORS.START;
            segments[segments.length - 2 - n].color = COLORS.START1;
            segments[segments.length - 3 - n].color = COLORS.START;
            console.log(segments.length);
            trackLength = segments.length * segmentLength;
        }

        function resetRoadImages4() {
            segments = [];

            addBumps();
            addBumps1();
            addStraight(ROAD.LENGTH.SHORT);
            addHill(ROAD.LENGTH.SHORT, ROAD.HILL.HIGH);
            addHill(ROAD.LENGTH.SHORT, ROAD.HILL.HIGH);
            addBumps(ROAD.LENGTH.SHORT);
            addCurve(ROAD.LENGTH.LONG, ROAD.CURVE.MEDIUM, ROAD.HILL.MEDIUM);
            addStraight(ROAD.LENGTH.SHORT);
            addCurve(ROAD.LENGTH.SHORT, -ROAD.CURVE.MEDIUM, ROAD.HILL.NONE);
            addBumps();
            addHill(ROAD.LENGTH.MEDIUM, ROAD.HILL.HIGH);
            addCurve(ROAD.LENGTH.MEDIUM, ROAD.CURVE.MEDIUM, -ROAD.HILL.LOW);
            addBumps1();
            addHill(ROAD.LENGTH.SHORT, -ROAD.HILL.MEDIUM);
            addStraight(ROAD.LENGTH.SHORT);
            addBumps();
            addSCurves();
            addDownhillToEnd();

            resetSpritesImages1();
            resetCars();

            segments[findSegment(playerZ).index + 1].color = COLORS.START;
            segments[findSegment(playerZ).index + 2].color = COLORS.START1;
            segments[findSegment(playerZ).index + 3].color = COLORS.START;
            console.log(segments.length);
            for (var n = 0; n < rumbleLength; n++)
                segments[segments.length - 1 - n].color = COLORS.START;
            segments[segments.length - 2 - n].color = COLORS.START1;
            segments[segments.length - 3 - n].color = COLORS.START;

            trackLength = segments.length * segmentLength;
        }

        function resetRoadImages5() {
            segments = [];

            addBumps();
            addBumps1();
            addBumps2();
            addStraight(ROAD.LENGTH.SHORT);
            addHill(ROAD.LENGTH.SHORT, ROAD.HILL.HIGH);
            addHill(ROAD.LENGTH.SHORT, ROAD.HILL.HIGH);
            addBumps(ROAD.LENGTH.SHORT);
            addCurve(ROAD.LENGTH.LONG, ROAD.CURVE.MEDIUM, ROAD.HILL.MEDIUM);
            addStraight(ROAD.LENGTH.SHORT);
            addHill(ROAD.LENGTH.MEDIUM, ROAD.HILL.HIGH);
            addBumps();
            addSCurves();
            addBumps1();
            addBumps2();
            addDownhillToEnd();

            resetSpritesImages1();
            resetCars();
            console.log(segments.length);
            segments[findSegment(playerZ).index + 1].color = COLORS.START;
            segments[findSegment(playerZ).index + 2].color = COLORS.START1;
            segments[findSegment(playerZ).index + 3].color = COLORS.START;

            for (var n = 0; n < rumbleLength; n++)
                segments[segments.length - 1 - n].color = COLORS.START;
            segments[segments.length - 2 - n].color = COLORS.START1;
            segments[segments.length - 3 - n].color = COLORS.START;

            trackLength = segments.length * segmentLength;
        }

        function resetRoadImages6() {
            segments = [];

            addStraight(ROAD.LENGTH.SHORT);
            addLowRollingHills(ROAD.LENGTH.LONG, 50);
            addDownhillToEnd();
            addStraight(ROAD.LENGTH.SHORT);


            resetSpritesImages1();
            resetCars();
            segments[findSegment(playerZ).index + 1].color = COLORS.START;
            segments[findSegment(playerZ).index + 2].color = COLORS.START1;
            segments[findSegment(playerZ).index + 3].color = COLORS.START;

            for (var n = 0; n < rumbleLength; n++)
                segments[segments.length - 1 - n].color = COLORS.START;
            segments[segments.length - 2 - n].color = COLORS.START1;
            segments[segments.length - 3 - n].color = COLORS.START;
            console.log(segments.length);
            trackLength = segments.length * segmentLength;
            //console.log(mapchoice[b - 1]);
        }

        function resetRoadImages7() {
            segments = [];

            addStraight(ROAD.LENGTH.SHORT);
            addCurve(ROAD.LENGTH.SHORT, ROAD.CURVE.MEDIUM, ROAD.HILL.MEDIUM);
            addSCurves();
            addCurve(ROAD.LENGTH.SHORT, ROAD.CURVE.MEDIUM, ROAD.HILL.MEDIUM);
            addCurve(ROAD.LENGTH.SHORT, ROAD.CURVE.MEDIUM, ROAD.HILL.LOW);
            addBumps();
            addLowRollingHills();
            addCurve(ROAD.LENGTH.SHORT, ROAD.CURVE.MEDIUM, -ROAD.HILL.LOW);
            addBumps();
            addHill(ROAD.LENGTH.SHORT, -ROAD.HILL.MEDIUM);
            addStraight();
            addSCurves();
            addDownhillToEnd();

            resetSpritesImages1();
            resetCars();

            segments[findSegment(playerZ).index + 1].color = COLORS.START;
            segments[findSegment(playerZ).index + 2].color = COLORS.START1;
            segments[findSegment(playerZ).index + 3].color = COLORS.START;

            for (var n = 0; n < rumbleLength; n++)
                segments[segments.length - 1 - n].color = COLORS.START;
            segments[segments.length - 2 - n].color = COLORS.START1;
            segments[segments.length - 3 - n].color = COLORS.START;
            console.log(segments.length);
            trackLength = segments.length * segmentLength;
        }

        function resetRoadImages8() {
            segments = [];

            addBumps();
            addBumps1();
            addStraight(ROAD.LENGTH.SHORT);
            addBumps(ROAD.LENGTH.SHORT);
            addCurve(ROAD.LENGTH.SHORT, ROAD.CURVE.MEDIUM, ROAD.HILL.MEDIUM);
            addHill(ROAD.LENGTH.SHORT, ROAD.HILL.HIGH);
            addCurve(ROAD.LENGTH.MEDIUM, ROAD.CURVE.MEDIUM, -ROAD.HILL.LOW);
            addBumps1();
            addHill(ROAD.LENGTH.SHORT, -ROAD.HILL.MEDIUM);
            addStraight(ROAD.LENGTH.SHORT);
            addBumps();
            addSCurves();
            addBumps1();

            resetSpritesImages1();
            resetCars();

            segments[findSegment(playerZ).index + 1].color = COLORS.START;
            segments[findSegment(playerZ).index + 2].color = COLORS.START1;
            segments[findSegment(playerZ).index + 3].color = COLORS.START;
            console.log(segments.length);
            for (var n = 0; n < rumbleLength; n++)
                segments[segments.length - 1 - n].color = COLORS.START;
            segments[segments.length - 2 - n].color = COLORS.START1;
            segments[segments.length - 3 - n].color = COLORS.START;

            trackLength = segments.length * segmentLength;
        }

        function resetRoadImages9() {
            segments = [];

            addBumps();
            addStraight(ROAD.LENGTH.SHORT);
            addBumps();
            addStraight(ROAD.LENGTH.SHORT);
            addSCurves();
            addCurve(ROAD.LENGTH.SHORT, ROAD.CURVE.MEDIUM, ROAD.HILL.SHORT);
            addHill(ROAD.LENGTH.SHORT, ROAD.HILL.HIGH);
            addCurve(ROAD.LENGTH.SHORT, ROAD.CURVE.MEDIUM, -ROAD.HILL.LOW);
            addBumps1();
            addHill(ROAD.LENGTH.SHORT, -ROAD.HILL.MEDIUM);
            addStraight(ROAD.LENGTH.SHORT);
            addBumps();
            addSCurves();
            addStraight(ROAD.LENGTH.SHORT);

            resetSpritesImages1();
            resetCars();
            console.log(segments.length);
            segments[findSegment(playerZ).index + 1].color = COLORS.START;
            segments[findSegment(playerZ).index + 2].color = COLORS.START1;
            segments[findSegment(playerZ).index + 3].color = COLORS.START;

            for (var n = 0; n < rumbleLength; n++)
                segments[segments.length - 1 - n].color = COLORS.START;
            segments[segments.length - 2 - n].color = COLORS.START1;
            segments[segments.length - 3 - n].color = COLORS.START;

            trackLength = segments.length * segmentLength;
        }
        //=====================================================================
        //                       Sprites Spawning
        //=====================================================================
        function resetSpritesImages1() {

            for (n = 0; n < (segments.length / 200) - 3; n++) {
                addSprite(100 + n * 200, { x: 0, y: 0, w: 3200, h: 1300 }, tree6, 0);
                addSprite(200 + n * 200, { x: 0, y: 0, w: 3200, h: 1300 }, tree7, 0);
            }
            for (n = 0; n < segments.length / 20; n++) {
                addSprite(20 * n, { x: 0, y: 0, w: 400, h: 387 }, billboard[0], 5);
                addSprite(20 * n, SPRITES.BILLBOARD[0], billboard[0], -5);
                addSprite(20 * n, SPRITES.BILLBOARD[1], billboard[0], 5);
                addSprite(20 * n, SPRITES.BILLBOARD[0], billboard[0], -5);
                addSprite(20 * n, { x: 0, y: 0, w: 400, h: 387 }, billboard[0], 6);
                addSprite(20 * n, SPRITES.BILLBOARD[0], billboard[0], -6);
                addSprite(20 * n, SPRITES.BILLBOARD[0], billboard[0], 6);
                addSprite(20 * n, SPRITES.BILLBOARD[0], billboard[0], -6);
                addSprite(20 * n, { x: 0, y: 0, w: 400, h: 387 }, billboard[0], 7);
                addSprite(20 * n, SPRITES.BILLBOARD[0], billboard[0], -7);
                addSprite(20 * n, SPRITES.BILLBOARD[0], billboard[0], 8);
                addSprite(20 * n, SPRITES.BILLBOARD[0], billboard[0], -8);
            }
            for (n = 0; n < segments.length / 5; n++) {
                addSprite(5 * n, SPRITES.BILLBOARD[1], billboard[1], -6 * Util.interpolate(0.3, 1, Math.random()));
                addSprite(5 * n, SPRITES.BILLBOARD[1], billboard[1], 6 * Util.interpolate(0.3, 1, Math.random()));
            }
            for (n = 0; n < (segments.length / 120) - 3; n++) {
                switch (n % 3) {
                    case 0: addSprite(30 + n * 120, { x: 0, y: 0, w: 150, h: 600 }, tree4, -.9); break;
                    case 1: addSprite(30 + n * 120, { x: 0, y: 0, w: 150, h: 600 }, tree5, -.9); break;
                    case 2: addSprite(30 + n * 120, { x: 0, y: 0, w: 150, h: 600 }, tree8, -.9); break;
                    default: addSprite(30 + n * 120, { x: 0, y: 0, w: 150, h: 600 }, tree4, -.9);
                }
               
            }
            for (n = 0; n < segments.length; n++) {
                addSprite(n, { x: 0, y: 0, w: 4104, h: 280 }, tree1, 2.6 * Util.interpolate(0.97, 1.05, Math.random()));
                addSprite(n, { x: 0, y: 0, w: 4104, h: 280 }, tree1, -2.6 * Util.interpolate(0.97, 1.05, Math.random()));
                addSprite(n, { x: 0, y: 0, w: 4104, h: 280 }, tree1, 5.4 * Util.interpolate(0.97, 1.05, Math.random()));
                addSprite(n, { x: 0, y: 0, w: 4104, h: 280 }, tree1, -5.4 * Util.interpolate(0.97, 1.05, Math.random()));
                addSprite(n, { x: 0, y: 0, w: 4104, h: 280 }, tree1, 7.4);
                addSprite(n, { x: 0, y: 0, w: 4104, h: 280 }, tree1, -7.4);
                addSprite(n, { x: 0, y: 0, w: 4104, h: 280 }, tree1, 9.4);
                addSprite(n, { x: 0, y: 0, w: 4104, h: 280 }, tree1, -9.4);

            }
            for (n = 0; n < segments.length / 20; n++) {
                addSprite(n * 20, { x: 0, y: 0, w: 600, h: 1200 }, tree2, 0.9);
                addSprite(n * 20, { x: 0, y: 0, w: 600, h: 1200 }, tree3, -0.9);
            }
            for (n = 0; n < segments.length / 10; n++) {
                addSprite(n * 10, { x: 0, y: 0, w: 4400, h: 1500 }, billboard3, 10);
                addSprite(n * 10, { x: 0, y: 0, w: 4400, h: 1500 }, billboard3, -10);
            }


        }

        function resetSpritesImages2() {
            for (n = 0; n < segments.length / 20; n++) {
                addSprite(n * 20, { x: 0, y: 0, w: 600, h: 1600 }, tree2, 0.8);
                addSprite(n * 20, { x: 0, y: 0, w: 600, h: 1600 }, tree3, -0.8);
            }
            for (n = 0; n < segments.length; n++) {
                addSprite(n, { x: 0, y: 0, w: 4104, h: 440 }, tree1, 2.6);
                addSprite(n, { x: 0, y: 0, w: 4104, h: 440 }, tree1, -2.6);
                addSprite(n, { x: 0, y: 0, w: 4104, h: 440 }, tree1, 5.4);
                addSprite(n, { x: 0, y: 0, w: 4104, h: 440 }, tree1, -5.4);
                addSprite(n, { x: 0, y: 0, w: 4104, h: 440 }, tree1, 7.4);
                addSprite(n, { x: 0, y: 0, w: 4104, h: 440 }, tree1, -7.4);
                addSprite(n, { x: 0, y: 0, w: 4104, h: 440 }, tree1, 9.4);
                addSprite(n, { x: 0, y: 0, w: 4104, h: 440 }, tree1, -9.4);

            }
        }

        function resetSpritesImages3() {
            addSprite(50, { x: 0, y: 0, w: 4104, h: 440 }, tree1, 2.6);
        }

        function resetSpritesImages4() {
        }

        function resetSpritesImages5() {
        }

        function resetSpritesImages6() {
            for (n = 0; n < segments.length / 20; n++) {
                addSprite(n * 20, { x: 0, y: 0, w: 600, h: 1600 }, tree2, 0.8);
                addSprite(n * 20, { x: 0, y: 0, w: 600, h: 1600 }, tree3, -0.8);
            }
            for (n = 0; n < segments.length; n++) {
                addSprite(n, { x: 0, y: 0, w: 4104, h: 440 }, tree1, 2.6);
                addSprite(n, { x: 0, y: 0, w: 4104, h: 440 }, tree1, -2.6);
                addSprite(n, { x: 0, y: 0, w: 4104, h: 440 }, tree1, 5.4);
                addSprite(n, { x: 0, y: 0, w: 4104, h: 440 }, tree1, -5.4);
                addSprite(n, { x: 0, y: 0, w: 4104, h: 440 }, tree1, 7.4);
                addSprite(n, { x: 0, y: 0, w: 4104, h: 440 }, tree1, -7.4);
                addSprite(n, { x: 0, y: 0, w: 4104, h: 440 }, tree1, 9.4);
                addSprite(n, { x: 0, y: 0, w: 4104, h: 440 }, tree1, -9.4);

            }
        }

        function resetSpritesImages7() {
            addSprite(50, { x: 0, y: 0, w: 4104, h: 440 }, tree1, 2.6);
        }

        function resetSpritesImages8() {
        }

        function resetSpritesImages9() {
        }
        //=====================================================================
        //                          Car Spawning
        //=====================================================================
        function resetCars() {
            cars = [];
            var n, car, segment, offset, z, sprite, speed, carImage;
            for (var n = 0; n < totalCars; n++) {
                var choicerandom = Math.random();
                if (choicerandom < 0.3) {
                    sprite = Util.randomChoice(SPRITES.CARS);
                }
                else {
                    sprite = Util.randomChoice(SPRITES.PROPS);
                }

                switch (sprite) {
                    case SPRITES.CARS[5]: moneyitem6(); break;
                    case SPRITES.CARS[4]: speedUpitem5(); break;
                    case SPRITES.CARS[3]: winditem4(); break;
                    case SPRITES.CARS[2]: clouditem3(); break;
                    case SPRITES.CARS[1]: ballonitem2(); break;
                    case SPRITES.CARS[0]: glassitem1(); break;

                    case SPRITES.PROPS[5]: walkable(); type = "prop"; carImage = prop6; break;
                    case SPRITES.PROPS[4]: walkable(); type = "prop"; carImage = prop5; break;
                    case SPRITES.PROPS[3]: walkable(); type = "prop"; carImage = prop4; break;
                    case SPRITES.PROPS[2]: walkable(); type = "prop"; carImage = prop3; break;
                    case SPRITES.PROPS[1]: walkable(); type = "prop"; carImage = prop2; break;
                    case SPRITES.PROPS[0]: walkable(); type = "prop"; carImage = prop1; break;
                }
                function moneyitem6() { if (ItemChoiceMoney) { nonwalkable(); type = "money"; carImage = item6; } else { sprite = SPRITES.PROPS[5]; walkable(); type = "prop"; carImage = prop6; }; }
                function speedUpitem5() { if (ItemChoiceSpeedUp) { nonwalkable(); type = "speedUp"; carImage = item5; } else { sprite = SPRITES.PROPS[4]; walkable(); type = "prop"; carImage = prop5; }; }
                function winditem4() { if (ItemChoiceWind) { nonwalkable(); type = "wind"; carImage = item4; } else { sprite = SPRITES.PROPS[3]; walkable(); type = "prop"; carImage = prop4; }; }
                function clouditem3() { if (ItemChoiceCloud) { nonwalkable(); type = "cloud"; carImage = item3; } else { sprite = SPRITES.PROPS[2]; walkable(); type = "prop"; carImage = prop3; }; }
                function ballonitem2() { if (ItemChoiceBallon) { nonwalkable(); type = "ballon"; carImage = item2; } else { sprite = SPRITES.PROPS[1]; walkable(); type = "prop"; carImage = prop2; }; }
                function glassitem1() { if (ItemChoiceGlass) { nonwalkable(); type = "glass"; carImage = item1; } else { sprite = SPRITES.PROPS[0]; walkable(); type = "prop"; carImage = prop1; }; }

                function walkable() {
                    z = Math.floor(Math.random() * segments.length) * segmentLength;
                    offset = Math.random() * Util.randomChoice([-0.7, 0.7]);
                    speed = Math.random() * 3000; //+ Math.random() / (sprite == SPRITES.SEMI ? 4 : 2) / 2;
                }
                function nonwalkable() {
                    z = Math.floor(Math.random() * segments.length) * segmentLength;
                    offset = Math.random() * Util.randomChoice([-0.8, 0.8]);
                    speed = 0;
                }
                car = { offset: offset, z: z, sprite: sprite, speed: speed, type: type, carImage: carImage };
                segment = findSegment(car.z);
                segment.cars.push(car);
                cars.push(car);

            }
        }

        //=========================================================================
        // THE GAME LOOP
        //=========================================================================
        function startGame() {
            if (IsStarted) return;
            Stage.NewGame = false;
            IsStarted = true;
            document.getElementById('controls').style.display = "block";
            document.getElementById('resetroadd').style.display = "block";
            document.getElementById('toast').style.background = "url('GameMap/CommonImages/starts.gif')";

            document.getElementById('toast').style.backgroundSize = "100% 100%";
            displayToast("<br>遊戲開始");
            document.getElementById('canvas').style.background = "url('')";
            // for (n = 0; n < 6; n++) {
            //    console.log(SPRITES.PROPS[n]);
            //    console.log(SPRITES.CARS[n]);
            // }
            Game.run({
                canvas: canvas, render: render, update: update, stats: stats, step: step,
                images:
                    ["background", "sprites", "playerFront", "item1", "item2", // 0 ,1 ,2 ,3 ,4
                        "item3", "item4", "item5", "tree1", "tree2", // 5 ,6 ,7 ,8 ,9
                        "tree3", "tree4", "tree5", "tree6", "tree7", // 10,11,12,13,14
                        "prop1", "prop2", "prop3", "prop4", "bg1", // 15,16,17,18,19
                        "bg2", "bg3", "item6", "billboard1", "billboard2", // 20,21,22,23,24
                        "billboard3", "prop5", "prop6","tree8"],                                  // 25,26,27
                keys: [
                    { keys: [KEY.LEFT, KEY.A], mode: 'down', action: function () { keyLeft = true; } },
                    { keys: [KEY.RIGHT, KEY.D], mode: 'down', action: function () { keyRight = true; } },
                    { keys: [KEY.UP, KEY.W], mode: 'down', action: function () { keyFaster = true; } },
                    { keys: [KEY.DOWN, KEY.S], mode: 'down', action: function () { keySlower = true; } },
                    { keys: [KEY.LEFT, KEY.A], mode: 'up', action: function () { keyLeft = false; } },
                    { keys: [KEY.RIGHT, KEY.D], mode: 'up', action: function () { keyRight = false; } },
                    { keys: [KEY.UP, KEY.W], mode: 'up', action: function () { keyFaster = false; } },
                    { keys: [KEY.DOWN, KEY.S], mode: 'up', action: function () { keySlower = false; } }
                ],
                ready: function (images) {
                    background = images[0];
                    sprites = images[1];
                    playerFront = images[2];
                    item1 = images[3];
                    item2 = images[4];
                    item3 = images[5];
                    item4 = images[6];
                    item5 = images[7];

                    tree1 = images[8];
                    tree2 = images[9];
                    tree3 = images[10];
                    tree4 = images[11];
                    tree5 = images[12];
                    tree6 = images[13];
                    tree7 = images[14];

                    prop1 = images[15];
                    prop2 = images[16];
                    prop3 = images[17];
                    prop4 = images[18];
                    bg1 = images[19];
                    bg2 = images[20];
                    bg3 = images[21];

                    item6 = images[22];

                    billboard1 = images[23];
                    billboard2 = images[24];
                    billboard3 = images[25];
                    prop5 = images[26];
                    prop6 = images[27];
                    tree8 = images[28];



                    props = [prop1, prop2, prop3, prop4, prop5, prop6];
                    trees = [tree1, tree2, tree3, tree4, tree5, tree6, tree7,tree8];
                    billboard = [billboard1, billboard2, billboard3]
                    // tree1 = images[16];

                    reset();


                    gamelevelstage();

                    //Dom.storage.fast_lap_time = Dom.storage.fast_lap_time || 180;
                    //updateHud('fast_lap_time', formatTime(Util.toFloat(Dom.storage.fast_lap_time)));

                }
            });
            // var nextlevelloop = true;
            // stopnext(nextlevelloop);
        }

        function NextGameStage() {
          
          var image1 =                 
                   ["background", "sprites", "playerFront", "item1"     , "item2"     , // 0 ,1 ,2 ,3 ,4
                    "item3"     , "item4"  , "item5"      , "tree1"     , "tree2"     , // 5 ,6 ,7 ,8 ,9
                    "tree3"     , "tree4"  , "tree5"      , "tree6"     , "tree7"     , // 10,11,12,13,14
                    "prop1"     , "prop2"  , "prop3"      , "prop4"     , "bg1"       , // 15,16,17,18,19
                    "bg2"       , "bg3"    , "item6"      , "billboard1", "billboard2", // 20,21,22,23,24
                    "billboard3", "prop5"  , "prop6"];                                  // 25,26,27

          Game.loadImages(image1, function (images) {
              background = images[0];
              sprites = images[1];
              playerFront = images[2];
              item1 = images[3];
              item2 = images[4];
              item3 = images[5];
              item4 = images[6];
              item5 = images[7];
              tree1 = images[8];
              tree2 = images[9];
              tree3 = images[10];
              tree4 = images[11];
              tree5 = images[12];
              tree6 = images[13];
              tree7 = images[14];
              prop1 = images[15];
              prop2 = images[16];
              prop3 = images[17];
              prop4 = images[18];
              bg1 = images[19];
              bg2 = images[20];
              bg3 = images[21];
              item6 = images[22];
              billboard1 = images[23];
              billboard2 = images[24];
              billboard3 = images[25];
              prop5 = images[26];
              prop6 = images[27];
              props = [prop1, prop2, prop3, prop4, prop5, prop6];
              trees = [tree1, tree2, tree3, tree4, tree5, tree6, tree7];
              billboard = [billboard1, billboard2, billboard3]
              // tree1 = images[16];
              
              
              reset();
              gamelevelstage();
              //Dom.storage.fast_lap_time = Dom.storage.fast_lap_time || 180;
              //updateHud('fast_lap_time', formatTime(Util.toFloat(Dom.storage.fast_lap_time)));

          });
        
          
      };

        function reset(options) {

            options = options || {};
            canvas.width = width = Util.toInt(options.width, width);
            canvas.height = height = Util.toInt(options.height, height);
            lanes = Util.toInt(options.lanes, lanes);
            totalCars = Util.toInt(options.totalCars, totalCars);
            roadWidth = Util.toInt(options.roadWidth, roadWidth);
            maxSpeed = Util.toInt(options.maxSpeed, maxSpeed);
            //  cameraHeight = Util.toInt(options.cameraHeight, cameraHeight);
            questionFrequency = Util.toInt(options.questionFrequency, questionFrequency);
            drawDistance = Util.toInt(options.drawDistance, drawDistance);
            fogDensity = Util.toInt(options.fogDensity, fogDensity);
            //   fieldOfView = Util.toInt(options.fieldOfView, fieldOfView);
            segmentLength = Util.toInt(options.segmentLength, segmentLength);
            rumbleLength = Util.toInt(options.rumbleLength, rumbleLength);
            cameraDepth = 1 / Math.tan((fieldOfView / 2) * Math.PI / 180);
            playerZ = (cameraHeight * cameraDepth);
            resolution = height / 480;
            maxTime = Util.toInt(options.maxTime, maxTime);
            //difficultylevel = Util.toInt(options.difficultylevel, difficultylevel);
            refreshTweakUI();

            switch (Number(mapchoice[b - 1])) {

                case 1: resetRoadImages1(); break;
                case 2: resetRoadImages2(); break;
                case 3: resetRoadImages3(); break;
                case 4: resetRoadImages4(); break;
                case 5: resetRoadImages5(); break;
                case 6: resetRoadImages6(); break;
                case 7: resetRoadImages7(); break;
                case 8: resetRoadImages8(); break;
                case 9: resetRoadImages9(); break;

            }
            console.log(mapchoice[b - 1]);
            if ((segments.length == 0) || (options.segmentLength) || (options.rumbleLength) || (options.totalCars)) {

                // console.log(mapchoice[b-1]);
            }
        }

     // function stopnext(nextlevelloop) {if (nextlevelloop) {setTimeout("NextGameStage()", maxTime * 1000);setTimeout("stoploop()", maxTime * 1000);}else {var highestTimeoutId = setTimeout(";");for (var i = 0; i < highestTimeoutId; i++) {clearTimeout(i);}};}
     // function stoploop() {var nextlevelloop = true; stopnext(nextlevelloop);} 

        //=========================================================================
        // TWEAK UI HANDLERS (for recalling and uploading game parameters)
        //=========================================================================

        Dom.on('resolution', 'change', function (ev) {
            var w, h, ratio;
            switch (ev.target.options[ev.target.selectedIndex].value) {
                case 'fine': w = 1280; h = 960; ratio = w / width; break;
                case 'high': w = 1024; h = 768; ratio = w / width; break;
                case 'medium': w = 640; h = 480; ratio = w / width; break;
                case 'low': w = 480; h = 360; ratio = w / width; break;
            }
            reset({ width: w, height: h })
            Dom.blur(ev);
        });
        Dom.on('difficultylevel', 'change', function (ev) {

            switch (ev.target.options[ev.target.selectedIndex].value) {
                case 'easy': difficultylevel = "easy", numberofquestion = 50; break;
                case 'medium': difficultylevel = "medium", numberofquestion = 50; break;
                case 'difficult': difficultylevel = "difficult", numberofquestion = 50; break;
                case 'withoutquestion': numberofquestion = 0; break;
            }

            Dom.blur(ev);
        });
        Dom.on('lanes', 'change', function (ev) { Dom.blur(ev); reset({ lanes: ev.target.options[ev.target.selectedIndex].value }); });
        Dom.on('roadWidth', 'change', function (ev) { Dom.blur(ev); reset({ roadWidth: Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });
        // Dom.on('cameraHeight', 'change', function (ev) { Dom.blur(ev); reset({ cameraHeight: Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });
        // Dom.on('drawDistance',   'change', function(ev) { Dom.blur(ev); reset({ drawDistance:  Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });
        // Dom.on('fieldOfView', 'change', function (ev) { Dom.blur(ev); reset({ fieldOfView: Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });
        //Dom.on('fogDensity',     'change', function(ev) { Dom.blur(ev); reset({ fogDensity:    Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });
        Dom.on('totalCars', 'change', function (ev) { /*console.log("changing");*/Dom.blur(ev); reset({ totalCars: Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });
        Dom.on('questionFrequency', 'change', function (ev) { Dom.blur(ev); reset({ questionFrequency: Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });
        Dom.on('maxSpeed', 'change', function (ev) { /*console.log("changing");*/Dom.blur(ev); reset({ maxSpeed: Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });
        Dom.on('maxTime', 'change',
            function (ev) { /*console.log("changing");*/
                Dom.blur(ev);
                reset({ maxTime: Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) });
            });
        document.getElementById('canvas').addEventListener('mousedown', GetStart2, false);

        document.getElementById('ItemChoiceMoney').addEventListener('change', function () { if (this.checked) { ItemChoiceMoney = true; reset(); } else { ItemChoiceMoney = false; reset(); } });
        document.getElementById('ItemChoiceSpeedUp').addEventListener('change', function () { if (this.checked) { ItemChoiceSpeedUp = true; reset(); } else { ItemChoiceSpeedUp = false; reset(); } });
        document.getElementById('ItemChoiceWind').addEventListener('change', function () { if (this.checked) { ItemChoiceWind = true; reset(); } else { ItemChoiceWind = false; reset(); } });
        document.getElementById('ItemChoiceCloud').addEventListener('change', function () { if (this.checked) { ItemChoiceCloud = true; reset(); } else { ItemChoiceCloud = false; reset(); } });
        document.getElementById('ItemChoiceBallon').addEventListener('change', function () { if (this.checked) { ItemChoiceBallon = true; reset(); } else { ItemChoiceBallon = false; reset(); } });
        document.getElementById('ItemChoiceGlass').addEventListener('change', function () { if (this.checked) { ItemChoiceGlass = true; reset(); } else { ItemChoiceGlass = false; reset(); } });
        document.getElementById('allitems').addEventListener('click', function () { ItemChoiceMoney = true; ItemChoiceSpeedUp = true; ItemChoiceWind = true; ItemChoiceCloud = true; ItemChoiceBallon = true; ItemChoiceGlass = true; reset(); });
        document.getElementById('allitemsnot').addEventListener('click', function () { ItemChoiceMoney = false; ItemChoiceSpeedUp = false; ItemChoiceWind = false; ItemChoiceCloud = false; ItemChoiceBallon = false; ItemChoiceGlass = false; reset(); });

        function refreshTweakUI() {
            Dom.get('difficultylevel').selectedIndex = ""
            Dom.get('lanes').selectedIndex = lanes - 1;
            Dom.get('currentRoadWidth').innerHTML = Dom.get('roadWidth').value = roadWidth;

            //  Dom.get('currentCameraHeight').innerHTML = Dom.get('cameraHeight').value = cameraHeight;
            //Dom.get('currentDrawDistance').innerHTML   = Dom.get('drawDistance').value   = drawDistance;
            // Dom.get('currentFieldOfView').innerHTML = Dom.get('fieldOfView').value = fieldOfView;
            //Dom.get('currentFogDensity').innerHTML = Dom.get('fogDensity').value = fogDensity;
            Dom.get('currenttotalCars').innerHTML = Dom.get('totalCars').value = totalCars;
            Dom.get('currentmaxSpeed').innerHTML = Dom.get('maxSpeed').value = maxSpeed;
            Dom.get('currentmaxTime').innerHTML = Dom.get('maxTime').value = maxTime;
            Dom.get('currentQuestionFrequency').innerHTML = Dom.get('questionFrequency').value = questionFrequency;

        }

        //=========================================================================
        // Background Audio Controller
        //=========================================================================
        function changeBGM() {
            document.getElementById("bgm").blur();
            var music = document.getElementById("audioContainer");
            music.pause();
            music.src = document.getElementById("bgm").value;
            music.play();
        }
        document.addEventListener('keydown', function (e) {
            //play music
            if (!musicAutoplay && e.key != "control" && e.key != "Alt" && e.key != "Meta" && e.key != "Shift" && e.key != "Tab") {
                var music = document.getElementById("audioContainer");
                var music1 = document.getElementById("audioContainer1");
                music.volume = 0.2;
                music.play();
                music1.volume = 0.05;
                music1.play();
                musicAutoplay = true;
            }
        //=========================================================================
        //        Question and Answer system setting
        //=========================================================================
        var questionBar_style = window.getComputedStyle(document.getElementById("questionBar"));
            if (questionBar_style.display != "none") {
                if (e.key == question_ans.toString()) {
                    correctAnswer();
                } else if (e.key == "1" || e.key == "2" || e.key == "3") {
                    wrongAnswer();
                } else if (Object.values(KEY).indexOf(e.keyCode) < 0) {
                    errorKeyPress();
                }
            }
        });
        async function correctAnswer() {
            var sound_effect = new Audio("sound effect/answer correctly.mp3");
            sound_effect.play();
            document.getElementById("correct").style.display = "block";
            await new Promise(r => setTimeout(r, 200));
            document.getElementById("questionBar").style.display = "none";
            await new Promise(r => setTimeout(r, 400));
            document.getElementById("correct").style.display = "none";
            numOfCrash += 3;
        }

        async function wrongAnswer() {
            var sound_effect = new Audio("sound effect/answer incorrectly.mp3");
            sound_effect.play();
            document.getElementById("wrong").style.display = "block";
            await new Promise(r => setTimeout(r, 800));
            document.getElementById("wrong").style.display = "none";
            numOfCrash -= 2;
        }

        async function errorKeyPress() {
            var sound_effect = new Audio("sound effect/answer incorrectly.mp3");
            sound_effect.play();
            document.getElementById("errorKey").style.display = "block";
            await new Promise(r => setTimeout(r, 1000));
            document.getElementById("errorKey").style.display = "none";
        }
        //=========================================================================
        //       Frieworks Setting
        //=========================================================================
        const max_fireworks = 5,
            max_sparks = 50;
        var ctx = canvas.getContext('2d');
        let fireworks = [];

        function drawsomething() {

            for (let i = 0; i < max_fireworks; i++) {
                let firework = {
                    sparks: []
                };
                for (let n = 0; n < max_sparks; n++) {
                    let spark = {
                        vx: Math.random() * 5 + .5,
                        vy: Math.random() * 5 + .5,
                        weight: Math.random() * .3 + .03,
                        red: Math.floor(Math.random() * 10),
                        green: Math.floor(Math.random() * 10),
                        blue: Math.floor(Math.random() * 10)
                    };
                    if (Math.random() > .5) spark.vx = -spark.vx;
                    if (Math.random() > .5) spark.vy = -spark.vy;
                    firework.sparks.push(spark);
                }
                fireworks.push(firework);
                resetFirework(firework);
            }
            window.requestAnimationFrame(explode);
        }
        function resetFirework(firework) {
            firework.x = Math.floor(Math.random() * canvas.width);
            firework.y = canvas.height;
            firework.age = 0;
            firework.phase = 'fly';
        }
        function explode() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            fireworks.forEach((firework, index) => {
                if (firework.phase == 'explode') {
                    firework.sparks.forEach((spark) => {
                        for (let i = 0; i < 10; i++) {
                            let trailAge = firework.age + i;
                            let x = firework.x + spark.vx * trailAge;
                            let y = firework.y + spark.vy * trailAge + spark.weight * trailAge * spark.weight * trailAge;
                            let fade = i * 200 * Math.random() - firework.age * Math.random();
                            let r = Math.floor(spark.red * fade * Math.random());
                            let g = Math.floor(spark.green * fade * Math.random());
                            let b = Math.floor(spark.blue * fade * Math.random());
                            ctx.beginPath();
                            ctx.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',.7)';
                            ctx.rect(x, y, 4, 4);
                            ctx.fill();
                        }
                    });
                    firework.age++;
                    if (firework.age > 100 && Math.random() < .05) {
                        resetFirework(firework);
                    }
                } else {
                    let ctx = canvas.getContext('2d');
                    firework.y = firework.y - 10;
                    for (let spark = 0; spark < 15; spark++) {
                        ctx.beginPath();
                        ctx.fillStyle = 'rgba(' + index * 20 + ',' + spark * 7 + ',0,1)';
                        ctx.rect(firework.x + Math.random() * spark - spark / 2, firework.y + spark * 4, 4, 4);
                        ctx.fill();
                    }
                    if (Math.random() < .001 || firework.y < 200) firework.phase = 'explode';
                }
            });
            window.requestAnimationFrame(explode);
        }
        //=========================================================================
        // Other Game Supporting Elements
        //=========================================================================
        function displayToast(msg, time) {
            var toast = $("#toast");
            var hide = function () { toast.removeClass("show"); }
            toast.html(msg);
            toast.addClass("show");
            clearTimeout(hide);
            if (time != "inf") setTimeout(hide, time || 2000);
        }

    </script>
</body> 
</html>
